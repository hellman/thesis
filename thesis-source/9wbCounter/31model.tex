\SubSecDef{model}{Security Model}

Consider a subproblem from the whitebox design problem. Recall that during the algebraic attack, the adversary tries to find a function $f$ of low degree $d$ such that when applied to values computed in the nodes of the obfuscated circuit it would produce some predictable value. Typically, predictable value is a value computed using the \emph{reference circuit} and it depends on a small fraction of the key. Our aim is to ``hide'' predictable values among unpredictable values. The unpredictability of computed functions may only come from the secret~key/randomness used during the obfuscation process. In order to develop a formal attack model we allow the obfuscated circuit to use \emph{random} bits. We underline that randomness here is merely an abstraction required for provable security arguments. 

In the real whitebox implementation the random bits may be implemented as \emph{pseudorandom} values computed from the input. Of course the pseudorandom generation part has to be protected as well. However, the white-box designer is free to choose arbitrary pseudorandom generator and its protection is an easier task then obfuscating a general circuit. For example, the designer can choose a random circuit satisfying some basic properties like computing a balanced function. The resulting circuit protected against the algebraic attack using pseudorandomly generated bits must further be obfuscated and protected from \emph{removal} of the pseudorandomness. This is type of protection that we called \emph{structure hiding} in \SecRef{method} and it is out of the scope of this work. It is indeed a challenging problem.

There is a strong similarity between the algebraic attack and the side channel probing attack. In the $t$-th order probing attack the adversary may observe $t$ intermediate values computed in the circuit. In the $d$-th order algebraic attack the adversary has access to all intermediate values but she can combine them only with a function of degree at most $d$.

\paragraph{Semantic Security.}
The main idea of masking schemes is to \emph{hide the values} computed in the reference circuit using (pseudo)random masks. We assume that the adversary knows the reference circuit. Given the inputs (e.g. a plaintext and a key) she can compute all intermediate values. The final goal of the adversary is to recover the key of an obfuscated implementation or, at least, learn some partial information about it. To formalize this, we adapt classic semantic security and indistinguishability ideas. The adversary may ask to encrypt two different vectors of inputs. The challenger chooses randomly one of the vectors and provides an oracle modelling the algebraic attack to the adversary. The goal of the adversary is to decide which of the vectors was encrypted. If she can not do this, then she can not learn any information about the hidden inputs (e.g. the plaintext and the key). Note that the adversary is allowed to choose many different keys which is not possible in the white-box scenario. However, it leads to simpler definitions since we do not have to distinguish plaintext and key and we just treat them as one input. It is possible to add a constraint allowing to choose only a single key per input vector, but this would not lead to any improvement.

\paragraph{Algebraic Attack Oracle.}
The oracle modelling the algebraic attack should not reveal too much information about computed values. Otherwise, it may be possible for the adversary to reconstruct the obfuscated circuit and then we would arrive in the general white-box scenario. We model the attack as follows: the adversary chooses the target function among linear (or higher-order) combinations of the intermediate functions in the circuit and she tries to guess its values during encryptions of the inputs from one of the two vectors. Note that some functions may have strong correlation with some function of the input. For a small vector of inputs the adversary may simply guess the value, ask the oracle a few times until the guess is correct and then compute the correlations. However, in the real algebraic attack this is not possible due to presence of "noise" in the circuit. For a small number of plaintexts there will be a lot of false matches for any "predicted" value, because there are many different functions computed in the circuit and it is highly probable that there is a linear combination of them matching an arbitrary value. We take this into account and require that only the function chosen by the adversary has to match the predicted value. As a result, the adversary can not accurately predict values of any \emph{single} function in the $d$-th order closure of the circuit functions in order to run the linear algebra attack. 

\paragraph{Encoding and Decoding.}
The circuit in the model can not take the input as it is, because these values allow for a simple distinguisher. Since we are developing a masking scheme, we assume that he inputs are already masked using random shares. The adversary targets masked operations, which we call \emph{critical computations}. This goes in parallel with the classic Boolean masking scenarios. We would like to stress that this is necessary in order to formally analyze the security of masked computations. Therefore, we do not consider the initial encoding and the final decoding processes. Indeed, these procedures are not relevant for the algebraic attack since they are not related to the reference circuit. Therefore, their protection is a part of the structure hiding component.

The security model is illustrated in \FigRef{masked-circuit}.

\begin{figure}
    \centering
    \includegraphics[height=8cm]{\PathFig{MaskedCircuitWB.png}}
    \FigDef{masked-circuit}{(Pseudo)randomness in a masked circuit.}
\end{figure}